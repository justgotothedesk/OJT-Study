# Thread 내에서의 다양한 변수 성능 비교(2)

### 실험 목표
- 3-1 실험에서 Regular Variable이 가장 빨랐던 오류를 보강하고, 추가적으로 다양한 변수를 추가하여 각 변수 간의 성능을 비교하여, 각 변수 유형이 성능에 어떻게 영향을 미치는지 이해한다.

### 변수 종류
- **Regular Global**: 일반 전역 변수. 동기화 없이 단순히 값을 증가시킨다.
- **Regular Local**: 일반 지역 변수.
- **TLS (Thread-Local Storage)**: 각 Thread가 독립적인 변수를 사용하여 Race condition을 방지한다.
- **Spinlock**: Spinlock을 통해 변수 접근을 보호하여 Race condition을 방지한다.
- **Semaphore**: Semaphore를 사용하여 동시 접근을 제어한다.
- **Atomic Global**: Atomic 전역 변수. Atomic 연산을 통해 변수 접근을 안전하게 보호한다.
- **Atomic Local**: Atomic 지역 변수. Atomic 연산을 통해 변수 접근을 안전하게 보호한다.
- **Array**: 각 Thread마다 array를 부여하여 TLS와 같은 역할을 하도록 한다.

## 실험 결과

### Thread #8

| Variable Type            | Execution Time (seconds) | Value  | Expected Value |
|--------------------------|--------------------------|--------|----------------|
| Regular Global Variable         | 0.017                    | 1,379,881 | 8,000,000      |
| Regular Local Variable   | 0.003                    | 8,000,000 | 8,000,000      |
| TLS Variable             | 0.028                    | 8,000,000 | 8,000,000      |
| Atomic Global Variable   | 0.138                    | 8,000,000 | 8,000,000      |
| Atomic Local Variable    | 0.015                    | 8,000,000 | 8,000,000      |
| Spinlock Variable        | 1.572                    | 8,000,000 | 8,000,000      |
| Semaphore Variable       | 39.309                   | 8,000,000 | 8,000,000      |
| Array Variable           | 0.005                    | 8,000,000 | 8,000,000      |

## 결과 분석
- **Regular Global**: 가장 빠르지만, 동시성 문제로 인해 예상치 않은 값이 나올 수 있다. 이 경우 8,000,000을 기대했지만 훨씬 낮은 1,379,881을 얻었다.
- **Regular Local**: 전역 변수보다 
- **TLS (Thread-Local Storage)**: 각 Thread가 독립적인 변수를 사용하여 Race condition을 방지한다.
- **Spinlock**: Thread가 변수에 접근할 때 Lock을 사용하여 다른 스레드의 접근을 막기에 Lock이 걸리는 동안 다른 Thread는 대기해야 하므로 성능이 떨어진다.
- **Semaphore**: Semaphore는 한 번에 하나의 Thread만 접근할 수 있도록 제어한다. Spinlock보다도 훨씬 느리다.
- **Atomic**: 일반 변수에 비해 성능이 약간 떨어지지만 높은 성능을 보여준다
- **Array**: TLS와 유사하다.

## 결론
- 3-1과 동일
